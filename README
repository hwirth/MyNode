==================================================================================================================119:=
                              SPIELWIESE - copy(l)eft 2022 - spielwiese.central-dogma.at
                                                  README for v0.0.3p
==================================================================================================================119:=

Index
	1. Overview
	2. File structure
	3. Mode of operation
		3.1. Messages and session handling
		3.2. Hot code reloading
		3.3. Persistent data
		3.4. Protocols
		3.5. Asynchronicity in object instantiation
	4. Configuration
	5. Installation
	6. TODO
	7. Code parking space


1. Overview
===========
WebSocketServer deals with connections and redirects messages between client and your business logic, called
"application" here. Furthermore, it provides automatic hot-reloading of the application code, simply hit ctrl+s and
reload the web page, or just have the client send the request again.


2. File structure
=================
	./start_server.sh            Runs node in a loop, terminates on certain exit codes
	./server/                    Code in this folder cannot be hot-reloaded
	./server/main.js             Web socket, http server, hot reload of application code
	./server/debug.js            Colored logging to stdout, log to file
	./server/config.js           Provides hard coded constants and values from the configuration file
	./server/reloader.js         Hot code-reloading. Reinstantiates the application for each request
	./application/               Hot reloadable code, responses to messages from the websocket
	./application/protocols.js   Calls response handler depending on given protocol and command
	./application/session.js     Main protocol, handles accounts and logins
	./application/chat/chat.js   Custom server protocol, simple text chat
	./htdocs                     Chat client and a debug thingy


3. Mode of operation
====================

3.1. Messages and session handling
----------------------------------
Messages to the websocket are expected to be stringified JSON objects of the following structure:

	{
		"<Protocol name>": {
			"<Command name>": {
				<Command specific arguments>
			}
		}
	}

The "session" protocol is handling logins, accounts and permissions. The client must authenticate before accessing
any further protocols with a message like:

	{
		"session": {
			"login": {
				username: '<username>',
				password: '<password>'
			}
		}
	}

Responses will follow the command structure like:

	{
		"session": {
			"login": {
				<specific response>
			}
		}
	}


3.2. Hot code reloading
-----------------------
The program is split into two parts: Persistent and ephemeral. Websocket events (i.e. onMessage) will first see, if any
modules in ./application/ have changed and will reload them and re-instantiate , before calling the updated actual event handlers contained
in said modules.


3.3. Persistent data
--------------------
The websocket itself is kept alive in the persistent part of the program, only the response handlers are hot reloaded.
Persistent data is stored in the main part as well. Application code will be given a reference to its data on
(re-)creation.


3.4. Protocols
--------------
Each message contains commands for specific protocols. These will be relayed accordingly through  protocols.js .
This allows for independent servers to run over the same websocket. Protocol code will be given a reference to its
persistent data, which is stored in  AppReloader.persistentData.<protocol name> .


3.5. Asynchronicity in object instantiation
-------------------------------------------
The whole program is probably to be considered a Singleton object.

[ ] // Initialize the object asynchronously
    // Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
    self.init().then( ()=>self );   // const chat = await new ChatServer();


3.6. Glue code in the main object
---------------------------------
//... Rephrase this
When sub-objects need to call methods of other objects which also need to call methods of the first object, we can't
just pass the all methods as callbacks when instantiating the first object, because the next one does not exist yet.
Therefore, "relay" functions in the main object are used for instantiation, because we are allowed to code calls for
things that don't yet exist, when the funcion is declared.




4. Configuration
================
/etc/spielwiese.conf


5. Installation
===============
$ npm install ws follow-redirects re-require-module


6. TODO
=======
[?]
	as
		username: <name>
		do
			<command>

[ ] server reset: clear persistent_data
[\] Less magic in  color_log() : let caller mix in COLOR.*
[!] Don't use colors except in color field with  color_log()
[?] Multiclienting as option per protocol
[ ] Make session state available to protocols
[ ] Execute commands in order
[ ] Several protocols in one request?
[!] Server: also log sent messages
#1: Implement rate limiting
#2: Restrict payload size
#4: Authenticate users before WS connection establishes


6.1. Problem with persistence of WebSocketClient instances
----------------------------------------------------------
Client connection information is kept in protocols.session.clients{}. Currently, each client entry also has callback
functions that hide the socket object from the rest of the application program. These client objects are instantiated
on connection and will not change, when some application code is reloaded. The user needs to close and log in again for
changes to take effect.

I should not store code in  persistent_data  to eliminate the requirement of reconnection after code update.
I could re-instantiate all  WebSocketServer()  instances, after code was reloaded, or find an alternative to things
like  client.send(data)  - e.g.  session.sendToClient( client.address, data );

callbacks.sendToClient( client.address, data ); - Have session.js "publish" its methods (globally? To certain modules)





7. Code Parking Space (Ignore)
==============================

https://ably.com/blog/web-app-websockets-nodejs
https://www.freecodecamp.org/news/how-to-secure-your-websocket-connections-d0be0996c556/
https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-16-04
(07:49:57 PM) madude: You can store the connect_id on the connection to identify them






	/*
		Object.keys( self.fileTimes ).forEach( (file_name)=>{
			const module = self.loadedModules[file_name];

			if (update_needed || (module == undefined)) {
				self.loadedModules[ file_name ] = {
					mtime: self.fileTimes[ file_name ],
				};

				load_requests.push(
					new Promise( (done)=>{
						if (DEBUG.RELOADER_REQUIRE) color_log(
							COLORS.REQUIRE,
							'AppReloader-re_require_modules:',
							file_name,
						);

						try {
							report_file_names[ file_name.replace('../','') ] = {};
							reRequire( path.resolve( file_name ) );

						} catch (error) {
							color_log(
								COLORS.ERROR,
								file_name,
								'could not be loaded',
							);

							const stringified_error = JSON.stringify(
								error,
								Object.getOwnPropertyNames( error ),
							).replace( /\\n/g, '<br>' );  //... Don't send HTML

							report_file_names[ file_name.replace('../','') ] = {
								error: stringified_error,
							};
						}

						done();
					})
				);
			} else {
				if (DEBUG.RELOADER_UP_TO_DATE) color_log(
					COLORS.UP_TO_DATE,
					'UP-TO-DATE:',
					file_name
				);
			}

		});

		await Promise.all( load_requests );

		if (socket && Object.keys( report_file_names ).length) {
			socket.send( JSON.stringify({ require: report_file_names }, null, '\t') );
		}

		return load_requests.length;
	*/








// client.js
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// SPIELWIESE - copy(l)eft 2022 - https://spielwiese.centra-dogma.at
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

const { DEBUG, COLORS, color_log } = require( '../server/debug.js' );
const { REASONS                  } = require( './constants.js' );


module.exports = function Client (persistent_data) {
	const self = this;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

	function init () {
		if (DEBUG.INSTANCES) color_log( COLORS.INSTANCES, 'Client.init' );

		return Promise.resolve();

	}; // init


	// Initialize the object asynchronously
	// Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
	init().then( ()=>self );

}; // Client


//EOF




(03:32:15 PM) hmw[at]: Trying to use git for once, I noticed, that I am all over the place with little changes here and there, when I am coding. Example: I added a newline for nicer formatting here, found a missing space there, fixed a typo, then added something more meaningful, so I made a commit for it. Now a lot of unrelated files had the commit message showing. Pausing everytime I do anything, in order to write a specific commit message, slows me down extremely and can take me out of the flow. Ideas?
(03:32:58 PM) Thedarkb-Work: It actually shits out commented header files with a message at the top saying that they're autogenerated, and if you want to edit them manually you totally can, but I'm aiming to eliminate that.
(03:33:33 PM) oldlaptop: hmw[at]: I don't know what level of knowledge you're at; are you not aware you get to decide which files (in fact which parts of which files) you add to a commit?
(03:34:03 PM) vdamewood: hmw[at]: Clean everything up in a single commit. Give that commit the message "Make minor fixes"
(03:34:11 PM) hmw[at]: Been coding since '84, but haven't used many modern tools. Severe case of NIH syndrome.
(03:34:12 PM) Thedarkb-Work: It puts all of the chunks inside of structs in an array, and then generates a hash table so accessing one chunk from another is O(1) usually.
(03:34:38 PM) vdamewood: hmw[at]: National institute of health?
(03:34:52 PM) Thedarkb-Work: When you save it rebuilds itself so this hash table becomes part of the next version of the editor.
(03:34:55 PM) oldlaptop: git add src/messy.c; git commit -m 'clean mess'; git add src/new-feature.c; git commit -m 'New support for frobbing widgets'
(03:34:56 PM) hmw[at]: "not invented here" - I never use frameworks and avoid libraries
(03:35:18 PM) oldlaptop: Traditionally that results in writing your own VCS
(03:35:21 PM) hmw[at]: I just found myself having added a new class and then it was too late to commit "minor fixes"
(03:35:46 PM) vdamewood: Sounds like you need to git stash
(03:35:55 PM) oldlaptop: You may also find git-add's -p option interesting.
(03:35:58 PM) merijn: And/or interactive add
(03:36:03 PM) hmw[at]: I have a nice workflow for version control. I just don't advertise it in the channels, I give support in :) I know I am "weird"
(03:36:07 PM) oldlaptop: (this is what merijn is talking about)
(03:36:52 PM) hmw[at]: Currently taken up the project of "going all in" with all the automatic code editors, fancy UI libraries and whatnot (Currently playing with node.js and a websocket)
(03:37:00 PM) oldlaptop: I'll also say almost the only thing I find GUI clients of any kind helpful for is reviewing a patch before committing.
(03:37:23 PM) vdamewood: oldlaptop: clients of what? Git?
(03:37:26 PM) oldlaptop: Yes.
(03:37:39 PM) vdamewood: oldlaptop: I prefer guis for looking at the commit history graph
(03:37:48 PM) oldlaptop: Yeah, that's about the only other thing
(03:38:05 PM) oldlaptop: I was about to describe it as "everything gitk's supposed to do"
(03:38:06 PM) vdamewood: The command-line way git does it is pretty good, but still limited by the command line.
(03:38:07 PM) hmw[at]: oldlaptop: ah, ic. RTFM mostly, I suppose :)
(03:38:36 PM) vdamewood: hmw[at]: We discourage RTFM in this channel, actually.
(03:38:38 PM) oldlaptop: For all the jokes, the manuals are pretty fun, and it's wise to read them
(03:38:41 PM) oldlaptop: (for git)
(03:39:06 PM) merijn: Sure
(03:39:13 PM) merijn: If your benchmark for fun is stabbing yourself :D
(03:39:13 PM) vdamewood: hmw[at]: Well, not Ring TFM, but rather saying such things to people. Rather, we prefer something more like linking to TFM and such.
(03:39:21 PM) hmw[at]: It is interesting, how messing with git makes me notice, how I *think*
(03:39:48 PM) hmw[at]: vdamewood: ic, can do that
(03:40:05 PM) ss[m]: then go with text-based gui for git, oldlaptop
(03:40:07 PM) oldlaptop: I would certainly expect using a VCS to affect how you work and think eventually. (And the precise effects will be different for different VCSes.)







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// HOT CODE RELOAD
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

	async function get_file_times () {
		const mtimes = [];
		const stat_requests = [];

		await new Promise( (done)=>{
			glob( APP_PATH + '/**/*.js', (error, matches)=>{
				if (error) color_log(
					COLORS.ERROR,
					'AppReloader-get_file_times:',
					error,
				);

				matches.forEach( (file_name)=>{
					stat_requests.push(
						fs.promises.stat( file_name ).then( (stats)=>{
							mtimes[file_name] = stats.mtimeMs;
						})
					);
				});

				done();
			});
		});

		await Promise.all( stat_requests );

		if (DEBUG.RELOADER_TIMES) color_log(
			COLORS.RELOADER,
			'AppReloader-get_file_times: File times:',
			mtimes,
		);

		return mtimes;

	} // get_file_times


	function find_changed_files () {
		const new_file_times = get_file_times();

		return Object.keys( self.fileTimes ).find( (file_name)=>{
			if (! self.loadedModules[ file_name ]) return true;

			const file_time   = self.fileTimes[ file_name ];
			const module_time = self.loadedModules[ file_name ];
			return (file_time != module_time);
		});

	} // find_changed_files


	function add_load_request (load_requests, report_file_names, file_name, file_has_changed) {
		load_requests.push(
			new Promise( (done)=>{
				if (file_has_changed) {
					if (DEBUG.RELOADER_REQUIRE) color_log(
						COLORS.REQUIRE,
						'AppReloader-re_require_modules:',
						file_name,
					);
				}
				report_file_names[ file_name.replace('../','') ] = {};

				try {
					reRequire( path.resolve( file_name ) );

				} catch (error) {
					color_log(
						COLORS.ERROR,
						file_name,
						'could not be loaded',
					);

					const stringified_error = JSON.stringify(
						error,
						Object.getOwnPropertyNames( error ),
					).replace( /\\n/g, '<br>' );  //... Don't send HTML

					report_file_names[ file_name.replace('../','') ] = {
						error: stringified_error,
					};
				}

				done();
			}),
		);

	} // add_load_request


	async function re_require_modules (socket) {
		const load_requests     = [];
		const report_file_names = {};

		const changed_files = find_changed_files();

		if (changed_files) {
			Object.keys( self.fileTimes ).forEach( (file_name)=>{
				self.loadedModules[ file_name ] = self.fileTimes[file_name];

				const file_has_changed = (changed_files.indexOf( file_name ) >= 0);
				add_load_request(
					load_requests,
					report_file_names,
					file_name,
					file_has_changed
				);
			});
		}

		await Promise.all( load_requests );

		if (socket && Object.keys( report_file_names ).length) {
			socket.send( JSON.stringify({ reload: report_file_names }, null, '\t') );
		}

		return load_requests.length;

	} // re_require_modules


	async function reload_modules (socket) {
		self.fileTimes = await get_file_times();

		console.time( 'Reload time' );
		const nr_reloaded_files = await re_require_modules( socket );
		console.timeEnd( 'Reload time' );
		if (nr_reloaded_files === 0) return;

		const MAIN_MODULE = {
			url            : APP_PATH + '/protocols.js',
			persistentData : self.persistentData,
			callbacks      : { triggerExit : callbacks.triggerExit },
		};

		console.time( 'Init time' );
		if (DEBUG.INSTANCES) color_log( COLORS.DEFAULT, '--init' + '-'.repeat(53) );
try {
		// Reload and reinstantiate main module:
		self.protocols = await new reRequire(
			MAIN_MODULE.url
		).Protocols(
			MAIN_MODULE.persistentData,
			MAIN_MODULE.callbacks,
		)/*.catch( (error)=>{
			color_log( COLORS.ERROR, 'AppReloader-reload_modules:', '.catch:', error );
		})*/;
} catch (error) {
	color_log( COLORS.ERROR, 'AppReloader-reload_modules:', 'try/catch:', error );
}
		if (DEBUG.INSTANCES) color_log( COLORS.DEFAULT, '--/init' + '-'.repeat(52) );
		console.timeEnd( 'Init time' );

	} // reload_modules


