==================================================================================================================119:=
                              SPIELWIESE - copy(l)eft 2022 - spielwiese.central-dogma.at
                                                  README for v0.0.3p
==================================================================================================================119:=

Index
	1. Overview
	2. File structure
	3. Mode of operation
		3.1. Messages and session handling
		3.2. Hot code reloading
		3.3. Persistent data
		3.4. Protocols
	4. Configuration
	5. Installation
	6. TODO
	7. Code parking space


1. Overview
===========
WebSocketServer deals with connections and redirects messages between client and your business logic, called
"application" here. Furthermore, it provides automatic hot-reloading of the application code, simply hit ctrl+s and
reload the web page, or just have the client send the request again.


2. File structure
=================
	./start_server.sh            Runs node in a loop, terminates on certain exit codes
	./server/                    Code in this folder cannot be hot-reloaded
	./server/main.js             Web socket, http server, hot reload of application code
	./server/debug.js            Colored logging to stdout, log to file
	./server/config.js           Provides hard coded constants and values from the configuration file
	./server/reloader.js         Hot code-reloading. Reinstantiates the application for each request
	./application/               Hot reloadable code, responses to messages from the websocket
	./application/protocols.js   Calls response handler depending on given protocol and command
	./application/session.js     Main protocol, handles accounts and logins
	./application/chat/chat.js   Custom server protocol, simple text chat
	./htdocs                     Chat client and a debug thingy


3. Mode of operation
====================

3.1. Messages and session handling
----------------------------------
Messages to the websocket are expected to be stringified JSON objects of the following structure:

	{
		"<Protocol name>": {
			"<Command name>": {
				<Command specific arguments>
			}
		}
	}

The "session" protocol is handling logins, accounts and permissions. The client must authenticate before accessing
any further protocols with a message like:

	{
		"session": {
			"login": {
				username: '<username>',
				password: '<password>'
			}
		}
	}


3.2. Hot code reloading
-----------------------
The program is split into two parts: Persistent and ephemeral. Websocket events (i.e. onMessage) will first see, if any
modules in ./application/ have changed and will reload them and re-instantiate , before calling the updated actual event handlers contained
in said modules.

3.3. Persistent data
--------------------
The websocket itself is kept alive in the persistent part of the program, only the response handlers are hot reloaded.
Persistent data is stored in the main part as well. Application code will be given a reference to its data on
(re-)creation.

3.4. Protocols
--------------
Each message contains commands for specific protocols. These will be relayed accordingly through  protocols.js .
This allows for independent servers to run over the same websocket. Protocol code will be given a reference to its
persistent data, which is stored in  AppReloader.persistentData.<protocol name> .


4. Configuration
================
/etc/spielwiese.conf


5. Installation
===============
$ npm install ws follow-redirects re-require-module


6. TODO
=======
[ ] .gitignore node_modules
[?] Multiclienting as option per protocol
[ ] Make session state available to protocols
[ ] Execute commands in order
[ ] Several protocols in one request?
[!] Server: also log sent messages
#1: Implement rate limiting
#2: Restrict payload size
#4: Authenticate users before WS connection establishes


7. Code Parking Space (Ignore)
==============================

https://www.freecodecamp.org/news/how-to-secure-your-websocket-connections-d0be0996c556/
https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-16-04
(07:49:57 PM) madude: You can store the connect_id on the connection to identify them



// client.js
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// SPIELWIESE - copy(l)eft 2022 - https://spielwiese.centra-dogma.at
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

const { DEBUG, COLORS, color_log } = require( '../server/debug.js' );
const { REASONS                  } = require( './constants.js' );


module.exports = function Client (persistent_data) {
	const self = this;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

	function init () {
		if (DEBUG.TRACE_INIT) color_log( COLORS.TRACE_INIT, 'Client.init' );

		return Promise.resolve();

	}; // init


	// Initialize the object asynchronously
	// Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
	init().then( ()=>self );

}; // Client


//EOF




(03:32:15 PM) hmw[at]: Trying to use git for once, I noticed, that I am all over the place with little changes here and there, when I am coding. Example: I added a newline for nicer formatting here, found a missing space there, fixed a typo, then added something more meaningful, so I made a commit for it. Now a lot of unrelated files had the commit message showing. Pausing everytime I do anything, in order to write a specific commit message, slows me down extremely and can take me out of the flow. Ideas?
(03:32:58 PM) Thedarkb-Work: It actually shits out commented header files with a message at the top saying that they're autogenerated, and if you want to edit them manually you totally can, but I'm aiming to eliminate that.
(03:33:33 PM) oldlaptop: hmw[at]: I don't know what level of knowledge you're at; are you not aware you get to decide which files (in fact which parts of which files) you add to a commit?
(03:34:03 PM) vdamewood: hmw[at]: Clean everything up in a single commit. Give that commit the message "Make minor fixes"
(03:34:11 PM) hmw[at]: Been coding since '84, but haven't used many modern tools. Severe case of NIH syndrome.
(03:34:12 PM) Thedarkb-Work: It puts all of the chunks inside of structs in an array, and then generates a hash table so accessing one chunk from another is O(1) usually.
(03:34:38 PM) vdamewood: hmw[at]: National institute of health?
(03:34:52 PM) Thedarkb-Work: When you save it rebuilds itself so this hash table becomes part of the next version of the editor.
(03:34:55 PM) oldlaptop: git add src/messy.c; git commit -m 'clean mess'; git add src/new-feature.c; git commit -m 'New support for frobbing widgets'
(03:34:56 PM) hmw[at]: "not invented here" - I never use frameworks and avoid libraries
(03:35:18 PM) oldlaptop: Traditionally that results in writing your own VCS
(03:35:21 PM) hmw[at]: I just found myself having added a new class and then it was too late to commit "minor fixes"
(03:35:46 PM) vdamewood: Sounds like you need to git stash
(03:35:55 PM) oldlaptop: You may also find git-add's -p option interesting.
(03:35:58 PM) merijn: And/or interactive add
(03:36:03 PM) hmw[at]: I have a nice workflow for version control. I just don't advertise it in the channels, I give support in :) I know I am "weird"
(03:36:07 PM) oldlaptop: (this is what merijn is talking about)
(03:36:52 PM) hmw[at]: Currently taken up the project of "going all in" with all the automatic code editors, fancy UI libraries and whatnot (Currently playing with node.js and a websocket)
(03:37:00 PM) oldlaptop: I'll also say almost the only thing I find GUI clients of any kind helpful for is reviewing a patch before committing.
(03:37:23 PM) vdamewood: oldlaptop: clients of what? Git?
(03:37:26 PM) oldlaptop: Yes.
(03:37:39 PM) vdamewood: oldlaptop: I prefer guis for looking at the commit history graph
(03:37:48 PM) oldlaptop: Yeah, that's about the only other thing
(03:38:05 PM) oldlaptop: I was about to describe it as "everything gitk's supposed to do"
(03:38:06 PM) vdamewood: The command-line way git does it is pretty good, but still limited by the command line.
(03:38:07 PM) hmw[at]: oldlaptop: ah, ic. RTFM mostly, I suppose :)
(03:38:36 PM) vdamewood: hmw[at]: We discourage RTFM in this channel, actually.
(03:38:38 PM) oldlaptop: For all the jokes, the manuals are pretty fun, and it's wise to read them
(03:38:41 PM) oldlaptop: (for git)
(03:39:06 PM) merijn: Sure
(03:39:13 PM) merijn: If your benchmark for fun is stabbing yourself :D
(03:39:13 PM) vdamewood: hmw[at]: Well, not Ring TFM, but rather saying such things to people. Rather, we prefer something more like linking to TFM and such.
(03:39:21 PM) hmw[at]: It is interesting, how messing with git makes me notice, how I *think*
(03:39:48 PM) hmw[at]: vdamewood: ic, can do that
(03:40:05 PM) ss[m]: then go with text-based gui for git, oldlaptop
(03:40:07 PM) oldlaptop: I would certainly expect using a VCS to affect how you work and think eventually. (And the precise effects will be different for different VCSes.)



