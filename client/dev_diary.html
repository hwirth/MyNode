<!DOCTYPE html><html id="top" lang="en" class="init animate"><head><meta charset="UTF-8">
<title>myNode Developer's Diary</title>
<link rel="help"          href="README">
<meta name="author"       content="hmw">
<meta name="creator"      content="hmw">
<meta name="publisher"    content="sec">
<meta name="generator"    content="MyNode RIDE">
<meta name="description"  content="Creating a server that allows me to remotely work on its very code while it is running">
<meta name="keywords"     content="node.js,functional programming,hot code reloading">
<meta name="robots"       content="noindex,nofollow">
<meta name="viewport"     content="width=device-width, initial-scale=1">
<meta name="color-scheme" content="dark light">
<style>
	* { margin:0; padding:0; }
	body { color:#fff; background:transparent; font-family:sans-serif; tab-size:4; }
	pre, code { font-family:monospace,monospace; font-size:0.9em; }
	article { position:relative; max-width:54em; border:solid 1px #fff4; border-radius:5px; background:#fff2; margin:1em auto; padding:0 1em; }
	body > :first-child { margin-top:0; }
	body > :last-child { margin-top:0; }
	:is(header, footer) > * { display:flex; justify-content:center; margin:5px 0; }
	article > * { padding:0 2em; }
	h1,h2,h3,h4,h5,h6,p,ul,ol,dl,table,pre { margin:1em 0; }
	h2 { position:relative; border-bottom:solid 1px #fff4; margin-top:1rem; padding:0; }
	h2 time { position:absolute; bottom:0; right:0em; width:6em; font-size:0.83rem; text-align:right; font-weight:normal; color:#fffa; }
	li { margin-left:1em; }
	ul + ul { margin-top:-1em; }
	[title] { cursor:help; }
	.niy {  }
	.included :is(header, footer) { display:none; }
</style><script>
	addEventListener( 'dblclick', ()=>location.reload() );
</script></head><body class="included">

<header><h1>myNode Developer's Diary</h1></header>

<article>
	<h2>Error Handling<time>Mon, 12<sup>h</sup>20<br>Nov 14, 2022</time></h2>
	<p>
		Error handling with Javascript is quite unreliable, when you got random code that might contain any kind
		of mistake, like forgetting make a function return a Promise. I often get error stacks completely unrelated
		to the mistake at hand, or no error is displayed even on the shell at all. At first it was my lack of
		understanding. but after learning and talking to people I found, that it can't be done reliably.
	</p>
	<p>
		Someone gave me the idea to run suspect code in a worker and see, if it crashes, which will not "mix"
		bogus asynchronous functions with the main thread. So I will have to refactor my prototype to run the
		application code inside a worker, which also may come with the benefit of some scalability.
	</p>
	<pre><code>
// These functions are hot reloaded on each websocket request.
// We have no control over any mistakes being made by a dev in these files.
// The dev might make mistakes.
// Server should catch all errors and report them back via websocket.

const test_functions = {
	test_sync: ()=>console.log('test_sync ran'),
	test_async: async()=>console.log('test_async ran'),
	normal_error: ()=>{ throw new Error('TEST ERROR') },
	promise_sync: ()=>{ new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	promise_async: async()=>{ new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	promise_await: async()=>{ await new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	undef_promise: ()=>new Promise( ()=>UNDEFINED_FUNCTION() ),

	// These ones confuse me:
	fatal1: ()=>{ new Promise(()=>{ throw new Error('FATAL ERROR') }) },
	fatal2: ()=>{ new Promise(()=>{ UNDEFINED_FUNCTION() }) },
	fatal3: ()=>{ new Promise(()=>{ UNDEFINED.method() }) },
}

for (let name in test_functions) {
	const test_function = test_functions[name];

	if (test_function.constructor.name === 'AsyncFunction') {
		try { await test_function().catch(e=>report(error,1)) }
		catch (error) { report(error,2) }
	}
	else {
		try { test_function().catch(error=>report(error,3)) }
		catch (error) { report(error,4) }
	}

	function report (error, nr) {
		console.groupCollapsed('GOOD:', nr, name, 'caught', error.message )
		console.log( test_function.toString() )
		console.log( error )
		console.trace()
		console.groupEnd()
	}
}
	</code></pre>
</article>

<article>
	<h2>What Is myNode?<time>Mon, 10<sup>h</sup>42<br>Nov 14, 2022</time></h2>
	<ul title="Implemented in my current prototype">
		<li>Another project that spiraled out of scope; I just wanted a websocket for my CSS poker table.
		<li>A debug shell running in the browser allows to read and format, then send JSON to the server.
		<li>The debug shell is actually a text chat and I will move my Curia chat to MyNode eventually.
		<li>My second ever node.js project, so I am learning a lot of new things right now
		<li>My first attempt at using the functional programming paradigm (pure functions) for a real project
		<li>The server can hot-reload <abbr>API</abbr> request handlers on the fly.
	</ul><ul style="color:#a00;" title="Not implemented yet">
		<li>The server can hot-reload itself on the fly.
		<li>Once the prototyping dust has settled, I can add payload code (services and client features).
		<li>The first payload features will be a remote code editor and a proper chat interface.
		<li>I'd like to use the MyNode debugger to read my emails and to chat on <abbr>IRC</abbr>
	</ul>

	<h4>Services</h4>
	<ul>
		<li>Remote IDE (myRIDE)
		<li>GIT
		<li>Eslint
		<li>News ticker
		<li><abbr>IRC</abbr> gateway
		<li><abbr>SMS</abbr> gateway
		<li>Email
		<li>Server logs (/var/log)
		<li>Server configuration (/etc)
		<li>Server control (systemctl, NetworkManager, ModemManager)
		<li>Hosting (Domains, email, ...)
	</ul>
</article>

<article>
	<h2>Started a WebSocket Project<time>Sat, 20<sup>h</sup>58<br>Oct 27, 2022</time></h2>
	<p>
		After quite a while has passed since I wrote a voice chat prototype with node.js,
		time has come for another project!
	</p>
</article>

<footer><span>copy(l)eft 2022 - <a href="https://spielwiese.central-dogma.at">spielwiese.central-dogma.at</a></span></footer>

<!--
	Enlightened: Remote bootstrapping of the server code base


-->
</body></html>
