<!DOCTYPE html><html id="top" lang="en" class="Xincluded"><head><meta charset="UTF-8">
<title>myNode Developer's Diary</title>
<link rel="help"          href="README">
<meta name="author"       content="hmw">
<meta name="creator"      content="hmw">
<meta name="publisher"    content="sec">
<meta name="generator"    content="MyNode RIDE">
<meta name="description"  content="Creating a server that allows me to remotely work on its very code while it is running">
<meta name="keywords"     content="node.js,functional programming,hot code reloading">
<meta name="robots"       content="noindex,nofollow">
<meta name="viewport"     content="width=device-width, initial-scale=1">
<!-- meta name="color-scheme" content="dark light" -->
<style>
	* { margin:0; padding:0; }
	body { color:#000; background:#ded; font-family:sans-serif; tab-size:4; }
	pre, code { font-family:monospace,monospace; font-size:0.9em; }
	article {
		position:relative; background:#fff2; background:#fff; color:#000;
		max-width:54em; margin:1em auto; padding:0 1em;
		border:solid 1px #0004; border-radius:5px;
	}
	body > :first-child { margin-top:0; }
	body > :last-child { margin-top:0; }
	:is(header, footer) > * { display:flex; justify-content:center; margin:5px 0 15px; }
	h1,h2,h3,h4,h5,h6,p,ul,ol,dl,table,pre { margin:1em 0; }
	h2 { position:relative; border-bottom:solid 1px #0004; margin-top:1rem; padding:0; }
	h2 time {
		position:absolute; bottom:0; right:0em; width:7em;
		font-size:0.83rem; text-align:right; font-weight:normal; color:#000a;
	}
	article > :not(h2) { padding:0 2rem; }
	li { margin-left:1em; }
	ul + ul { margin-top:-1em; }
	[title] { cursor:help; }
	.included body { color:#fff; background:transparent; }
	.included article { color:#fff; background:#fff3; }
	.included :is(header, footer) { display:none; }
	.included h2,
	.included article { border-color:#fff4; }
	.included h2 time { color:#fffa; }
	.hidden { display:none; }
</style><script>
	console.log( 'reload' );
	addEventListener( 'dblclick', ()=>location.reload() );
	if (get('included')) addEventListener( 'load', ()=>{
		document.querySelector( 'html' ).classList.add( 'included' );
		document.querySelectorAll( 'article' ).forEach( (article, index)=>{
			article.classList.toggle( 'hidden', index > 0 );
		});
	});
	function get (search) {
		if ((location.href.indexOf( 'all' ) >= 0) && (search != 'separators')) return true;
		return search.split(' ').reduce( (prev, term)=>{
			return prev || (location.href.indexOf( term ) >= 0);
		}, false);

	}
</script></head><body>

<header><h1>myNode Developer's Diary</h1></header>

<article>
	<h2>RSS and Clickable Links<time>Wed, 13<sup>h</sup>01<br>Nov 16, 2022</time></h2>
	<p>
		A few tweaks here and there, not all errors caught, because it is impossible without wrapping the
		response handlers in workser, which might not even be such a bad idea for v2.0.
	<p>
		I noticed considerable lag between clicking a toggle and the bit confirming, so I disabled syntax
		token highlighting. Instead now links are clickable.
</article>

<article>
	<h2>Line Height Woes Continue<time>Tue, 16<sup>h</sup>30<br>Nov 15, 2022</time></h2>
	<p>
		I keep fighting vertical text alignment since that mysterious Firefox update close to a year ago.
		Firefox insists of adding a pixel to line height, or does some other thing with font rendering
		with a similar effect.
	<p>
		So far, I get best results in all browsers with tricks like <code>padding:1.5px horiz 2.5px</code>.
	<p>
		I kept asking around since many of my layouts "broke" that day, and the really odd part about it is,
		that nobody has even noticed. Either they all no longer test with all major browsers, or they have
		some normalizers, that have found a solution. Perhaps I should try a normalizer and see, if they
		prevent the problem from happening. That way I would find the trick and also what was changed in
		Firefox.
</article>

<article>
	<h2>Error Handling<time>Mon, 12<sup>h</sup>20<br>Nov 14, 2022</time></h2>
	<p>
		Error handling with Javascript is quite unreliable, when you got random code that might contain any kind
		of mistake, like forgetting make a function return a Promise. I often get error stacks completely unrelated
		to the mistake at hand, or no error is displayed even on the shell at all. At first it was my lack of
		understanding. but after learning and talking to people I found, that it can't be done reliably.
	<p>
		Someone gave me the idea to run suspect code in a worker and see, if it crashes, which will not "mix"
		bogus asynchronous functions with the main thread. So I will have to refactor my prototype to run the
		application code inside a worker, which also may come with the benefit of some scalability.
	<pre><code>
// These functions are hot reloaded on each websocket request.
// We have no control over any mistakes being made by a dev in these files.
// The dev might make mistakes.
// Server should catch all errors and report them back via websocket.

const test_functions = {
	test_sync: ()=>console.log('test_sync ran'),
	test_async: async()=>console.log('test_async ran'),
	normal_error: ()=>{ throw new Error('TEST ERROR') },
	promise_sync: ()=>{ new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	promise_async: async()=>{ new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	promise_await: async()=>{ await new Promise().then((res,rej) => UNDEFINED_FUNCTION) },
	undef_promise: ()=>new Promise( ()=>UNDEFINED_FUNCTION() ),

	// These ones confuse me:
	fatal1: ()=>{ new Promise(()=>{ throw new Error('FATAL ERROR') }) },
	fatal2: ()=>{ new Promise(()=>{ UNDEFINED_FUNCTION() }) },
	fatal3: ()=>{ new Promise(()=>{ UNDEFINED.method() }) },
}

for (let name in test_functions) {
	const test_function = test_functions[name];

	if (test_function.constructor.name === 'AsyncFunction') {
		try { await test_function().catch(e=>report(error,1)) }
		catch (error) { report(error,2) }
	}
	else {
		try { test_function().catch(error=>report(error,3)) }
		catch (error) { report(error,4) }
	}

	function report (error, nr) {
		console.groupCollapsed('GOOD:', nr, name, 'caught', error.message )
		console.log( test_function.toString() )
		console.log( error )
		console.trace()
		console.groupEnd()
	}
}
	</code></pre>
</article>

<article>
	<h2>What Is myNode?<time>Mon, 10<sup>h</sup>42<br>Nov 14, 2022</time></h2>
	<ul title="Implemented in my current prototype">
		<li>Another project that spiraled out of scope; I just wanted a websocket for my CSS poker table.
		<li>A debug shell running in the browser allows to read and format, then send JSON to the server.
		<li>The debug shell is actually a text chat and I will move my Curia chat to MyNode eventually.
		<li>My second ever node.js project, so I am learning a lot of new things right now
		<li>My first attempt at using the functional programming paradigm (pure functions) for a real project
		<li>The server can hot-reload <abbr>API</abbr> request handlers on the fly.
	</ul><ul style="color:#a00;" title="Not implemented yet">
		<li>The server can hot-reload itself on the fly.
		<li>Once the prototyping dust has settled, I can add payload code (services and client features).
		<li>The first payload features will be a remote code editor and a proper chat interface.
		<li>I'd like to use the MyNode debugger to read my emails and to chat on <abbr>IRC</abbr>
	</ul>

	<h4>Services</h4>
	<ul>
		<li>Remote IDE (myRIDE)
		<li>GIT
		<li>Eslint
		<li>News ticker
		<li><abbr>IRC</abbr> gateway
		<li><abbr>SMS</abbr> gateway
		<li>Email
		<li>Torrent
		<li>Server logs (/var/log)
		<li>Server configuration (/etc)
		<li>Server control (systemctl, NetworkManager, ModemManager)
		<li>Hosting (Domains, email, ...)
	</ul>
</article>

<article>
	<h2>Started a WebSocket Project<time>Sat, 20<sup>h</sup>58<br>Oct 27, 2022</time></h2>
	<p>
		After quite a while has passed since I wrote a voice chat prototype with node.js,
		time has come for another project!
</article>

<footer><span>copy(l)eft 2022 - <a href="https://spielwiese.central-dogma.at">spielwiese.central-dogma.at</a></span></footer>

<!--
	Enlightened: Remote bootstrapping of the server code base


-->
</body></html>
