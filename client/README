==================================================================================================================119:=
                              SPIELWIESE - copy(l)eft 2022 - spielwiese.central-dogma.at
                                                  README for v0.0.5p
==================================================================================================================119:=


*** At the moment, this   R E A D M E   I S   O U T D A T E D   per definition ***


Index
	1. Overview
	2. File structure
	3. Mode of operation
		3.1. Messages and session handling
		3.2. Hot code reloading
		3.3. Persistent data
		3.4. Protocols
		3.5. Asynchronicity in object instantiation
	4. Configuration
	5. Installation
	6. TODO
	7. Code parking space


1. Overview
===========
 "Spielwiese" is to be a general websocket server fulfilling all needs of my home page (chat, games, tools, etc.).
Server side code can be edited through the browser client and hot reloaded on the fly.

  WebSocketServer()  deals with connections and communicates messages between client and (what it considers) business
logic, called "application" here. It also provides automatic hot-reloading and is kept to the viable minimum required
for that.

 The rest of the Spielwiese is implemented as application, which deals in analysing the request, routing it to the
appropriate server module ("protocol"), session handling, etc., and a minmal preliminary chat server as placeholder for
the real payloads. The collection of servers in the  ./application/  directory is called "protocols", payload servers
live in sub-directories.



2. File structure
=================
	./start_server.sh            Runs node in a loop, terminates on certain exit codes
	./server/                    Code in this folder cannot be hot-reloaded
	./server/main.js             Web socket, http server, hot reload of application code
	./server/debug.js            Colored logging to stdout, log to file
	./server/config.js           Provides hard coded constants and values from the configuration file
	./server/reloader.js         Hot code-reloading. Reinstantiates the application for each request
	./application/               Hot reloadable code, responses to messages from the websocket
	./application/router.js      Calls response handler according to requested protocol/command
	./application/session.js     Main protocol, handles accounts and logins
	./application/client.js
	./application/chat/chat.js   Custom server protocol, simple text chat
	./htdocs                     Chat client and a debug thingy


3. Mode of operation
====================

3.1. Messages and session handling
----------------------------------
Messages to the websocket are expected to be stringified JSON objects of the following structure:

	{
		"<Protocol name>": {
			"<Command name>": {
				<Command specific arguments>
			}
		}
	}

The "session" protocol is handling logins, accounts and permissions. The client must authenticate before accessing
any further protocols with a message like:

	{
		"session": {
			"login": {
				username: '<username>',
				password: '<password>'
			}
		}
	}

Responses will follow the command structure like:

	{
		"session": {
			"login": {
				<specific response>
			}
		}
	}


3.2. Hot code reloading
-----------------------
The program is split into two parts: Persistent and ephemeral. Websocket events (i.e. onMessage) will first see, if any
modules in ./application/ have changed and will reload them and re-instantiate , before calling the updated actual event handlers contained
in said modules.


3.3. Persistent data
--------------------
The websocket itself is kept alive in the persistent part of the program, only the response handlers are hot reloaded.
Persistent data is stored in the main part as well. Application code will be given a reference to its data on
(re-)creation.


3.4. Protocols
--------------
Each message contains commands for specific protocols. These will be relayed accordingly through  protocols.js .
This allows for independent servers to run over the same websocket. Each protocol implementation will be given a
reference to its respective persistent data, which is stored in  AppReloader.persistentData.<protocol name> .

Some protocols need special callbacks, for instance  triggerExit , which allows a protocol to cause a full restart of
the server. How protocols are created and interconnected is configured by hand in  Protocols.init() .


3.5. Asynchronicity in object instantiation
-------------------------------------------
The whole program is probably to be considered a Singleton object.

[ ] // Initialize the object asynchronously
    // Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
    self.init().then( ()=>self );   // const chat = await new ChatServer();


3.6. Glue code in the main object
---------------------------------
//... Rephrase this
When sub-objects need to call methods of other objects which also need to call methods of the first object, we can't
just pass the all methods as callbacks when instantiating the first object, because the next one does not exist yet.
Therefore, "relay" functions in the main object are used for instantiation, because we are allowed to code calls for
things that don't yet exist, when the funcion is declared.
//EOF

4. Configuration
================
/etc/spielwiese.conf

RUN_AS_USER           spielwiese
RUN_AS_GROUP          spielwiese
DOCUMENT_ROOT         /.../htdocs

LOG_TO_CONSOLE        true
LOG_TO_FILE           false
LOG_FILE_NAME         /.../spielwiese.log

SSL_PUBLIC_KEY_FILE   /.../spielwiese.crt
SSL_PRIVATE_KEY_FILE  /.../spielwiese.key

HTTPS_PORT            1337
WS_PORT               1337


//EOF
