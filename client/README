==================================================================================================================119:=
                              SPIELWIESE - copy(l)eft 2022 - spielwiese.central-dogma.at
                                                  README for v0.0.5p
==================================================================================================================119:=


*** At the moment, this   R E A D M E   I S   O U T D A T E D   per definition ***


Index
	1. Overview
	2. File structure
	3. Mode of operation
		3.1. Messages and session handling
		3.2. Hot code reloading
		3.3. Persistent data
		3.4. Protocols
		3.5. Asynchronicity in object instantiation
	4. Configuration
	5. Installation
	6. TODO
	7. Code parking space


1. Overview
===========
 "Spielwiese" is to be a general websocket server fulfilling all needs of my home page (chat, games, tools, etc.).
Server side code can be edited through the browser client and hot reloaded on the fly.

  WebSocketServer()  deals with connections and communicates messages between client and (what it considers) business
logic, called "application" here. It also provides automatic hot-reloading and is kept to the viable minimum required
for that.

 The rest of the Spielwiese is implemented as application, which deals in analysing the request, routing it to the
appropriate server module ("protocol"), session handling, etc., and a minmal preliminary chat server as placeholder for
the real payloads. The collection of servers in the  ./application/  directory is called "protocols", payload servers
live in sub-directories.



2. File structure
=================
	./start_server.sh            Runs node in a loop, terminates on certain exit codes
	./server/                    Code in this folder cannot be hot-reloaded
	./server/main.js             Web socket, http server, hot reload of application code
	./server/debug.js            Colored logging to stdout, log to file
	./server/config.js           Provides hard coded constants and values from the configuration file
	./server/reloader.js         Hot code-reloading. Reinstantiates the application for each request
	./application/               Hot reloadable code, responses to messages from the websocket
	./application/router.js      Calls according response handler to requested protocol/command
	./application/session.js     Main protocol, handles accounts and logins
	./application/client.js
	./application/chat/chat.js   Custom server protocol, simple text chat
	./htdocs                     Chat client and a debug thingy


3. Mode of operation
====================

3.1. Messages and session handling
----------------------------------
Messages to the websocket are expected to be stringified JSON objects of the following structure:

	{
		"<Protocol name>": {
			"<Command name>": {
				<Command specific arguments>
			}
		}
	}

The "session" protocol is handling logins, accounts and permissions. The client must authenticate before accessing
any further protocols with a message like:

	{
		"session": {
			"login": {
				username: '<username>',
				password: '<password>'
			}
		}
	}

Responses will follow the command structure like:

	{
		"session": {
			"login": {
				<specific response>
			}
		}
	}


3.2. Hot code reloading
-----------------------
The program is split into two parts: Persistent and ephemeral. Websocket events (i.e. onMessage) will first see, if any
modules in ./application/ have changed and will reload them and re-instantiate , before calling the updated actual event handlers contained
in said modules.


3.3. Persistent data
--------------------
The websocket itself is kept alive in the persistent part of the program, only the response handlers are hot reloaded.
Persistent data is stored in the main part as well. Application code will be given a reference to its data on
(re-)creation.


3.4. Protocols
--------------
Each message contains commands for specific protocols. These will be relayed accordingly through  protocols.js .
This allows for independent servers to run over the same websocket. Each protocol implementation will be given a
reference to its respective persistent data, which is stored in  AppReloader.persistentData.<protocol name> .

Some protocols need special callbacks, for instance  triggerExit , which allows a protocol to cause a full restart of
the server. How protocols are created and interconnected is configured by hand in  Protocols.init() .


3.5. Asynchronicity in object instantiation
-------------------------------------------
The whole program is probably to be considered a Singleton object.

[ ] // Initialize the object asynchronously
    // Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
    self.init().then( ()=>self );   // const chat = await new ChatServer();


3.6. Glue code in the main object
---------------------------------
//... Rephrase this
When sub-objects need to call methods of other objects which also need to call methods of the first object, we can't
just pass the all methods as callbacks when instantiating the first object, because the next one does not exist yet.
Therefore, "relay" functions in the main object are used for instantiation, because we are allowed to code calls for
things that don't yet exist, when the funcion is declared.
//EOF

4. Configuration
================
/etc/spielwiese.conf

RUN_AS_USER           spielwiese
RUN_AS_GROUP          spielwiese
DOCUMENT_ROOT         /.../htdocs

LOG_TO_CONSOLE        true
LOG_TO_FILE           false
LOG_FILE_NAME         /.../spielwiese.log

SSL_PUBLIC_KEY_FILE   /.../spielwiese.crt
SSL_PRIVATE_KEY_FILE  /.../spielwiese.key

HTTPS_PORT            1337
WS_PORT               1337


5. Installation
===============
$ npm install ws follow-redirects re-require-module


6. Debugging
============
ssh -p <port> -L 1339:127.0.0.1:1339 spielwiese



6. TODO
=======
[ ] .mark
[ ] First toggle fails
[ ] self.router.protocols.session.broadcast( message );  -- flag/object describing who gets full error
[ ] <header><main><footer> - put output/input into main
[ ] WANT TO PLAY A GAME?
[ ] broadcast, update, notice, debug protocols
[?] Don't client.send/broadcast, return results to router
[ ] self.debugConsole.print( message, 'response' ); --> ( 'response', message )
[ ] Connection throttling: ADVICE: TRY AGAIN IN 5207 MILLISECONDS WITH TAG D822AE3A74
[ ] as [ before | (username,password) [do <command>| continue] ]
[ ] "MCP asleep"
[ ] Keyboard toggles --> buttons
[ ] Tabbed mode: Command on modifier+Return
[ ] Restore session after page reload (allows browsing the web page while playing)
[ ] DEFCON
[ ] /clear
[ ] JSON message single string: special format
[ ] whoami
[ ] Paths? whoami --> mcp status whoami
[ ] onclick everywhere --> focus
[ ] mcp inspect: <path>, maxDepth: <depth>
[ ] Normal responses only contain collapsable text. 'tag: <id>' request non-collapsible content of recent response
[ ] console single click: text --> elements.input
[ ] protocols --> services
[ ] client.respond --> return
[ ] {} ==> EMPTY
[ ] Timeout after logout not cleared
[ ] server reset: clear persistent
[\] Less magic in  color_log() : let caller mix in COLOR.*
[!] Don't use colors except in color field with  color_log()
[?] Multiclienting as option per protocol
[ ] Make session state available to protocols
[ ] Execute commands in order
[ ] Several protocols in one request?
[!] Server: also log sent messages
#1: Implement rate limiting
#2: Restrict payload size
#4: Authenticate users before WS connection establishes


6.1 Git
-------
--paginate
git commit --amend

(04:31:00 AM) EdFletcher: hmw[at]: along the same lines, take a look at interactive rebase. it's a very powerful tool
for reworking commits which encourages you to make many small commits (as you can always rework them later). so in your
case you could make frequent commits that only touch one or a few files, then arrange them contextually into related
commits later.
(04:39:22 AM) EdFletcher: hmw[at]: PlanckWalk: you're both welcome, happy to be able to help! i'm 100% in on the rebase
workflow myself, so much so that i honestly forget how merge works frequently. this atlassian article is surprisingly
good at detailing the differences in a digestible way: https://www.atlassian.com/git/tutorials/merging-vs-rebasing

6.2. Problem with persistence of WebSocketClient instances
----------------------------------------------------------
Client connection information is kept in protocols.session.clients{}. Currently, each client entry also has callback
functions that hide the socket object from the rest of the application program. These client objects are instantiated
on connection and will not change, when some application code is reloaded. The user needs to close and log in again for
changes to take effect.

I should not store code in  persistent  to eliminate the requirement of reconnection after code update.
I could re-instantiate all  WebSocketServer()  instances, after code was reloaded, or find an alternative to things
like  client.send(data)  - e.g.  session.sendToClient( client.address, data );

callbacks.sendToClient( client.address, data ); - Have session.js "publish" its methods (globally? To certain modules)


6.2. Error handling
-------------------
* async forEach,
* forEach( asnyc (entry)=>...
* Nesting try/catch
* Forgetting that some function is async



7. Code Parking Space (Ignore)
==============================
	as
		username: <name>
		do
			<command>




router:
		const command_lut = create_command_lut();
		function create_command_lut () {
			const lut = {};

			Object.keys( self.protocols ).forEach( (protocol_name)=>{
				const protocol_commands = self.protocols[protocol_name].request;

				if (protocol_commands) {
					Object.keys( protocol_commands ).forEach( (command_name)=>{
						const combined = protocol_name + '.' + command_name;
						lut[combined] = protocol_commands[command_name];
					});
				}
			});

			return lut;
		}


		const handled_commands = [];
		const rejected_commands = [];






https://ably.com/blog/web-app-websockets-nodejs
https://www.freecodecamp.org/news/how-to-secure-your-websocket-connections-d0be0996c556/
https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-16-04
(07:49:57 PM) madude: You can store the connect_id on the connection to identify them






	/*
		Object.keys( self.fileTimes ).forEach( (file_name)=>{
			const module = self.loadedModules[file_name];

			if (update_needed || (module == undefined)) {
				self.loadedModules[ file_name ] = {
					mtime: self.fileTimes[ file_name ],
				};

				load_requests.push(
					new Promise( (done)=>{
						if (DEBUG.RELOADER_REQUIRE) color_log(
							COLORS.REQUIRE,
							'AppReloader-re_require_modules:',
							file_name,
						);

						try {
							report_file_names[ file_name.replace('../','') ] = {};
							reRequire( path.resolve( file_name ) );

						} catch (error) {
							color_log(
								COLORS.ERROR,
								file_name,
								'could not be loaded',
							);

							const stringified_error = JSON.stringify(
								error,
								Object.getOwnPropertyNames( error ),
							).replace( /\\n/g, '<br>' );  //... Don't send HTML

							report_file_names[ file_name.replace('../','') ] = {
								error: stringified_error,
							};
						}

						done();
					})
				);
			} else {
				if (DEBUG.RELOADER_UP_TO_DATE) color_log(
					COLORS.UP_TO_DATE,
					'UP-TO-DATE:',
					file_name
				);
			}

		});

		await Promise.all( load_requests );

		if (socket && Object.keys( report_file_names ).length) {
			socket.send( JSON.stringify({ require: report_file_names }, null, '\t') );
		}

		return load_requests.length;
	*/








// client.js
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// SPIELWIESE - copy(l)eft 2022 - https://spielwiese.centra-dogma.at
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

const { DEBUG, COLORS, color_log } = require( '../server/debug.js' );
const { REASONS                  } = require( './constants.js' );


module.exports = function Client (persistent) {
	const self = this;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

	function init () {
		if (DEBUG.INSTANCES) color_log( COLORS.INSTANCES, 'Client.init' );

		return Promise.resolve();

	}; // init


	// Initialize the object asynchronously
	// Makes sure, a reference to this instance is returned to  const protocol = await new Protocol();
	init().then( ()=>self );

}; // Client





(03:32:15 PM) hmw[at]: Trying to use git for once, I noticed, that I am all over the place with little changes here and there, when I am coding. Example: I added a newline for nicer formatting here, found a missing space there, fixed a typo, then added something more meaningful, so I made a commit for it. Now a lot of unrelated files had the commit message showing. Pausing everytime I do anything, in order to write a specific commit message, slows me down extremely and can take me out of the flow. Ideas?
(03:32:58 PM) Thedarkb-Work: It actually shits out commented header files with a message at the top saying that they're autogenerated, and if you want to edit them manually you totally can, but I'm aiming to eliminate that.
(03:33:33 PM) oldlaptop: hmw[at]: I don't know what level of knowledge you're at; are you not aware you get to decide which files (in fact which parts of which files) you add to a commit?
(03:34:03 PM) vdamewood: hmw[at]: Clean everything up in a single commit. Give that commit the message "Make minor fixes"
(03:34:11 PM) hmw[at]: Been coding since '84, but haven't used many modern tools. Severe case of NIH syndrome.
(03:34:12 PM) Thedarkb-Work: It puts all of the chunks inside of structs in an array, and then generates a hash table so accessing one chunk from another is O(1) usually.
(03:34:38 PM) vdamewood: hmw[at]: National institute of health?
(03:34:52 PM) Thedarkb-Work: When you save it rebuilds itself so this hash table becomes part of the next version of the editor.
(03:34:55 PM) oldlaptop: git add src/messy.c; git commit -m 'clean mess'; git add src/new-feature.c; git commit -m 'New support for frobbing widgets'
(03:34:56 PM) hmw[at]: "not invented here" - I never use frameworks and avoid libraries
(03:35:18 PM) oldlaptop: Traditionally that results in writing your own VCS
(03:35:21 PM) hmw[at]: I just found myself having added a new class and then it was too late to commit "minor fixes"
(03:35:46 PM) vdamewood: Sounds like you need to git stash
(03:35:55 PM) oldlaptop: You may also find git-add's -p option interesting.
(03:35:58 PM) merijn: And/or interactive add
(03:36:03 PM) hmw[at]: I have a nice workflow for version control. I just don't advertise it in the channels, I give support in :) I know I am "weird"
(03:36:07 PM) oldlaptop: (this is what merijn is talking about)
(03:36:52 PM) hmw[at]: Currently taken up the project of "going all in" with all the automatic code editors, fancy UI libraries and whatnot (Currently playing with node.js and a websocket)
(03:37:00 PM) oldlaptop: I'll also say almost the only thing I find GUI clients of any kind helpful for is reviewing a patch before committing.
(03:37:23 PM) vdamewood: oldlaptop: clients of what? Git?
(03:37:26 PM) oldlaptop: Yes.
(03:37:39 PM) vdamewood: oldlaptop: I prefer guis for looking at the commit history graph
(03:37:48 PM) oldlaptop: Yeah, that's about the only other thing
(03:38:05 PM) oldlaptop: I was about to describe it as "everything gitk's supposed to do"
(03:38:06 PM) vdamewood: The command-line way git does it is pretty good, but still limited by the command line.
(03:38:07 PM) hmw[at]: oldlaptop: ah, ic. RTFM mostly, I suppose :)
(03:38:36 PM) vdamewood: hmw[at]: We discourage RTFM in this channel, actually.
(03:38:38 PM) oldlaptop: For all the jokes, the manuals are pretty fun, and it's wise to read them
(03:38:41 PM) oldlaptop: (for git)
(03:39:06 PM) merijn: Sure
(03:39:13 PM) merijn: If your benchmark for fun is stabbing yourself :D
(03:39:13 PM) vdamewood: hmw[at]: Well, not Ring TFM, but rather saying such things to people. Rather, we prefer something more like linking to TFM and such.
(03:39:21 PM) hmw[at]: It is interesting, how messing with git makes me notice, how I *think*
(03:39:48 PM) hmw[at]: vdamewood: ic, can do that
(03:40:05 PM) ss[m]: then go with text-based gui for git, oldlaptop
(03:40:07 PM) oldlaptop: I would certainly expect using a VCS to affect how you work and think eventually. (And the precise effects will be different for different VCSes.)







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/
// HOT CODE RELOAD
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////119:/

	async function get_file_times () {
		const mtimes = [];
		const stat_requests = [];

		await new Promise( (done)=>{
			glob( SETTINGS.APP_PATH + '/**/*.js', (error, matches)=>{
				if (error) color_log(
					COLORS.ERROR,
					'AppReloader-get_file_times:',
					error,
				);

				matches.forEach( (file_name)=>{
					stat_requests.push(
						fs.promises.stat( file_name ).then( (stats)=>{
							mtimes[file_name] = stats.mtimeMs;
						})
					);
				});

				done();
			});
		});

		await Promise.all( stat_requests );

		if (DEBUG.RELOADER_TIMES) color_log(
			COLORS.RELOADER,
			'AppReloader-get_file_times: File times:',
			mtimes,
		);

		return mtimes;

	} // get_file_times


	function find_changed_files () {
		const new_file_times = get_file_times();

		return Object.keys( self.fileTimes ).find( (file_name)=>{
			if (!self.loadedModules[ file_name ]) return true;

			const file_time   = self.fileTimes[ file_name ];
			const module_time = self.loadedModules[ file_name ];
			return (file_time != module_time);
		});

	} // find_changed_files


	function add_load_request (load_requests, report_file_names, file_name, file_has_changed) {
		load_requests.push(
			new Promise( (done)=>{
				if (file_has_changed) {
					if (DEBUG.RELOADER_REQUIRE) color_log(
						COLORS.REQUIRE,
						'AppReloader-re_require_modules:',
						file_name,
					);
				}
				report_file_names[ file_name.replace('../','') ] = {};

				try {
					reRequire( path.resolve( file_name ) );

				} catch (error) {
					color_log(
						COLORS.ERROR,
						file_name,
						'could not be loaded',
					);

					const stringified_error = JSON.stringify(
						error,
						Object.getOwnPropertyNames( error ),
					).replace( /\\n/g, '<br>' );  //... Don't send HTML

					report_file_names[ file_name.replace('../','') ] = {
						error: stringified_error,
					};
				}

				done();
			}),
		);

	} // add_load_request


	async function re_require_modules (socket) {
		const load_requests     = [];
		const report_file_names = {};

		const changed_files = find_changed_files();

		if (changed_files) {
			Object.keys( self.fileTimes ).forEach( (file_name)=>{
				self.loadedModules[ file_name ] = self.fileTimes[file_name];

				const file_has_changed = (changed_files.indexOf( file_name ) >= 0);
				add_load_request(
					load_requests,
					report_file_names,
					file_name,
					file_has_changed
				);
			});
		}

		await Promise.all( load_requests );

		if (socket && Object.keys( report_file_names ).length) {
			socket.send( JSON.stringify({ reload: report_file_names }, null, '\t') );
		}

		return load_requests.length;

	} // re_require_modules


	async function reload_modules (socket) {
		self.fileTimes = await get_file_times();

		console.time( 'Reload time' );
		const nr_reloaded_files = await re_require_modules( socket );
		console.timeEnd( 'Reload time' );
		if (nr_reloaded_files === 0) return;

		const MAIN_MODULE = {
			url            : SETTINGS.APP_PATH + '/protocols.js',
			persistentData : self.persistentData,
			callbacks      : { triggerExit : callbacks.triggerExit },
		};

		console.time( 'Init time' );
		if (DEBUG.INSTANCES) color_log( COLORS.DEFAULT, '--init' + '-'.repeat(53) );
try {
		// Reload and reinstantiate main module:
		self.protocols = await new reRequire(
			MAIN_MODULE.url
		).Protocols(
			MAIN_MODULE.persistentData,
			MAIN_MODULE.callbacks,
		)/*.catch( (error)=>{
			color_log( COLORS.ERROR, 'AppReloader-reload_modules:', '.catch:', error );
		})*/;
} catch (error) {
	color_log( COLORS.ERROR, 'AppReloader-reload_modules:', 'try/catch:', error );
}
		if (DEBUG.INSTANCES) color_log( COLORS.DEFAULT, '--/init' + '-'.repeat(52) );
		console.timeEnd( 'Init time' );

	} // reload_modules












		const new_rules = {
			'connecting': {
				include: [],
				templates: [
					{
						session: {
							status: 'empty',
						},
					},
					{
						session: {
							login: {
								username: 'string',
								password: 'string',
							}
						},
					},
				],
			},
			'guest': {
				include: [],
				templates: [
					{
						session: {
							status: 'empty',
						},
					},
					{
						session: {
							logout: 'empty',
						},
					},
					{
						session: {
							who: 'empty',
						},
					},
					{
						session: {
							who: {
								address: 'string',
							},
						},
					},
					{
						session: {
							who: {
								username: 'string',
							},
						},
					},
				],
			},
			'user': {
				include: [ 'guest' ],
				templates: [
				],
			},
			'mod': {
				include: [ 'user' ],
				templates: [
					{
						session: {
							kick: {
								address: 'empty',
							},
						},
					},
					{
						session: {
							kick: {
								username: 'empty',
							},
						},
					},
				],
			},
			'admin': {
				include: [ 'mod' ],
				templates: [
					{
						session: {
							status: {
								persistent: 'empty',
							},
						},
					},
					{
						server: {
							restart: 'empty',
						},
					},
				],
			},
			'dev': {
				include: [ 'admin'  ],
				templates: [
				],
			},
		};





	app.prototype.interface = {
		mcp: {
			system: {
				status :null

			},
			devices: {
				cpu :null
				gpu :null
				storage :null
				network :null
				usb :null
				midi :null
				audio :null
				video :null
				vr :null
				ar :null

			}
			connections: {
				ssh: {
					hio: "-p 7899 mcp@192.168.12.7"
				}
			}
		}
		help :null
	}












		/// SEND ///

		self.requestId = 0;

		self.elements.send.addEventListener( 'click', ()=>{

			function execute (data) {
				const command
				= (typeof data == 'string')
				? text_to_request(data)
				: data
				;

				command.tag = ++self.requestId;

				callback.send( command );
				self.elements.input.value = '';
				self.elements.input.focus();
			}

			let text = self.elements.input.value;
			execute( text.trim() );
			return;
/*
			let bang = null;
			const has_bang = BANGS.find( bang => text.charAt(0) == bang );
			if (has_bang) {
				bang = text.charAt(0);
				text = text.slice(1).trim();

				execute( text );
				return;
			}


			text = text.replace(/\s\s+/g, ' ').trim();
			//string.replace(/\s\s+/g, ' ');
			//string.replace(/  +/g, ' ');
*/
/*

			// Syntax: 'session login username:* password:*\tadditional parameter:*'
			// matches: session login username:user password:pass additional parameter:text
			//
			//   session
			//     login
			//       username: user
			//       password: pass
			//     additional
			//       parameter: text

			const COMMAND_SYNTAX = [
				'session login username:* password:*',
				'session login username:* password:* \tlogout',
				'session logout',
				'session status',
				'session who',
			];

			function create_json (command, parameters, syntax) {
				const tokens = {
					command : command.split(' '),
					syntax  : syntax.split(' '),
				};

				let indentation = '';
				let result      = '';

				tokens.command.forEach( (token, index) => {
					result += indentaion + token;

					const has_colon = tokens.syntax[index].indexOf('\t') >= 0;
					const has_tab = tokens.syntax[index].indexOf('\t') >= 0;
					if (has_tab) {
					}
				});
				return text_to_command( result );
			}

			const command = text;
			const valid_request = COMMAND_SYNTAX.find( (syntax, index) => {
				const words      = command.split(' ');
				const parameters = [];
				let synthesized  = '';

				syntax
				.replace('\t', ' ')
				.replace('*', ' *')
				.split(' ').forEach( (token, index)=>{
					if (token == '*') {
						parameters.push( words[index] );
						synthesized += ' ' + words[index];
					} else {
						synthesized += ' ' + token;
					}
				});

				synthesized = synthesized.trim();

				if (synthesized == command) {
					const translated = create_json( command, parameters, syntax );
					execute( translated );
					return true;
				} else {
					return false;
				}
			});

			if (! valid_request) {
				self.print( text, 'request' );
				self.print( 'Malformed request', 'cep' );
			}
*/

			/// PARSE MACROS ///

			const COMMAND_SYNTAX = [
				{
					syntax: 'session login username: * password: *',
					create: (username, password)=>{
						return {
							session: {
								login: {
									username: username,
									password: password,
								},
							},
						};
					},
				},
				{
					syntax: 'session logout',
					create: ()=>{
						return {
							session: {
								logout: {},
							},
						};
					},
				},
				{
					syntax: 'session status',
					create: ()=>{
						return {
							session: {
								status: {},
							},
						};
					},
				},
				{
					syntax: 'session who',
					create: ()=>{
						return {
							session: {
								who: {},
							},
						};
					},
				},
				{
					syntax: 'session kick username: *',
					create: (name)=>{
						return {
							session: {
								kick: {
									username: name,
								},
							},
						};
					},
				},
				{
					syntax: 'session kick address: *',
					create: (address)=>{
						return {
							session: {
								kick: {
									address: address,
								},
							},
						};
					},
				},
				{
					syntax: 'chat say: *',
					create: (text)=>{
						return {
							chat: {
								say: text,
							},
						};
					},
				},
				{
					syntax: 'mcp status',
					create: ()=>{
						return {
							mcp: {
								status: {},
							},
						};
					},
				},
				{
					syntax: 'mcp inspect',
					create: (param)=>{
						return {
							mcp: {
								inspect: param,
							},
						};
					},
				},
				{
					syntax: 'mcp inspect reloader',
					create: (param)=>{
						return {
							mcp: {
								inspect: {
									reloader: param,
								},
							},
						};
					},
				},
				{
					syntax: 'mcp restart',
					create: ()=>{
						return {
							mcp: {
								restart: {},
							},
						};
					},
				},
			];


			const request = COMMAND_SYNTAX.find( (request, index)=>{
				const syntax = request.syntax.split(' ');

				const parameters = [];
				let synthesized  = '';
				const words = text.split(' ');
				syntax.forEach( (_, index)=>{
					if (syntax[index] == '*') {
						parameters.push( words[index] );
						synthesized += ' ' + words[index];
					} else {
						synthesized += ' ' + syntax[index];
					}
				});
				synthesized = synthesized.trim();


				if (text == synthesized) {
					const translated = COMMAND_SYNTAX[index].create(...parameters)

					console.log( 'X', text );
					console.log( 'S', synthesized );
					console.log( 'T', translated );
					console.log( 'P', parameters );

					execute( translated );
					return true;
				} else {
					return false;
				}
			});

			if (! request) {
				self.print( text, 'request' );
				self.print( 'Malformed request', 'cep' );
			}
		});























/*
@font-face {
	font-family: 'mode7';
	src: url('/fonts/ModeSeven.woff2') format('woff2');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
@font-face {
	font-family: 'seti';
	src: url('/fonts/SETIPERU.woff') format('woff');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
@font-face {
	font-family: 'crt';
	src: url('/fonts/DIGIT.woff') format('woff');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: 'gothic';
	src: url('/fonts/gothic.woff') format('woff');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
@font-face {
	font-family: 'fa-regular';
	src: url('/fonts/fa-regular-400.woff2') format('woff2');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
@font-face {
	font-family: 'fa-brands';
	src: url('/fonts/fa-brands-400.woff2') format('woff2');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
@font-face {
	font-family: 'fa-solid';
	src: url('/fonts/fa-solid-900.woff2') format('woff2');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}
*/











/*
	width: 100%;
	height: 100vh;
	display: flex;
	align-items: center;
	justify-content: center;

	background-size: 300% 300%;
	background-color:#000;
	Xbackground-image: linear-gradient(
		45deg,
		rgba(  0,  0,255,1) 0%,
		rgba(255,  0,  0,1) 100%
	);

	animation: HTML 30s ease infinite;
	overflow: hidden;
*/




/*
html { background:var(--bg-html); }
body {
	display:grid;
	grid-template-areas:
		"ga-header  ga-header"
		"ga-path-menu ga-main-menu"
		"ga-article ga-article"
		"ga-footer ga-footer"
	;
	grid-template-rows:min-content min-content auto min-content;
	Xgrid-template-columns:auto auto;
	Xmax-width:60em;
	min-height:100vh;
	Xborder:var(--border-bg); border-width:var(--body-border-width);
	margin:0 auto;
	font-family:var(--font-family);
	background:var(--body-bg); color:var(--text-color);
	line-height:1.5;
}
header     { grid-area:ga-header;    padding:0 var(--body-padding); }
.main_menu { grid-area:ga-main-menu; padding:0 var(--body-padding) 0 0; }
.path_menu { grid-area:ga-path-menu; padding:0 0 0 var(--body-padding); }
article    { grid-area:ga-article;   padding:0 var(--body-padding); }
footer     { grid-area:ga-footer;    padding:0 var(--body-padding); }

header { background:var(--bg-header); padding-top:var(--header-padding-top); padding-bottom:var(--header-padding-btm); }
.debug header { padding-top:0.5em; }
header > * { display:inline; }
header img { height:2em; }
.init header img { height:unset; }
header small { font-weight:normal; font-size:0.85em; }

nav { font-size:0; }
nav { padding-top:var(--menu-padding); padding-bottom:var(--menu-padding); }
nav a { font-size:1rem; }

nav.main_menu,
nav.path_menu { padding-top:var(--menu-padding); padding-bottom:var(--menu-padding); }

nav.main_menu { background:var(--bg-main-menu); text-align:right; }
nav.main_menu a { margin-left:1.5em; white-space:nowrap; }

nav.path_menu { background:var(--bg-path-menu); }
nav.path_menu a::after { display:inline-block; content:'>'; margin:0 0.5em; color:var(--text-color); text-decoration:none; }
nav.path_menu a:last-child::after { display:none; }

article { background:var(--bg-article); padding-top:3rem; padding-bottom:5rem; }

a        { color:var(--a-color); text-decoration:none; }
a:hover  { color:var(--a-hover); text-decoration:underline; }
a:active { color:var(--a-active); }
a:focus  { color:var(--a-focus); }

h1 { font-size:1.35em; }
h2 { font-size:1.1em; }

footer { background:var(--bg-footer); text-align:center; padding:var(--footer-padding); }
.debug footer { padding-bottom:0.25rem; }

footer span::after { content: ' - '; }
footer span:last-child::after { display:none; }
*/
